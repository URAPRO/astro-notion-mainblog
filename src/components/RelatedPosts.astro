---
import type { Post, SelectProperty } from '../lib/interfaces.ts';
import { getPostLink, filePath } from '../lib/blog-helpers.ts';

export interface Props {
  currentPost: Post;
  allPosts: Post[];
  maxPosts?: number;
}

const { currentPost, allPosts, maxPosts = 3 } = Astro.props;

interface ScoredPost extends Post {
  score: number;
}

// Helper function to calculate common tags between two sets of tags
function calculateCommonTags(tags1: SelectProperty[] | undefined, tags2: SelectProperty[] | undefined): number {
  if (!tags1 || !tags2 || tags1.length === 0 || tags2.length === 0) {
    return 0;
  }
  return tags1.filter(t1 => tags2.some(t2 => t2.name === t1.name)).length;
}

let relatedPostsToDisplay: Post[] = [];

// --- 1. 手動で設定された関連記事を取得 ---
// currentPost.RelatedPostPageIds に基づいて、手動で指定された関連記事をrelatedPostsToDisplayの初期リストとして設定します。
// この際、カレント記事自身は除外します。
if (currentPost.RelatedPostPageIds && currentPost.RelatedPostPageIds.length > 0) {
  relatedPostsToDisplay = currentPost.RelatedPostPageIds
    .map(pageId => allPosts.find(p => p.PageId === pageId))
    .filter(p => p !== undefined && p.PageId !== currentPost.PageId) as Post[];
}

// --- 2. InternalTags に基づく関連記事のスコアリング ---
// allPosts から、InternalTags がカレント記事と共通する記事を候補として収集し、スコアリングします。
// スコアは共通するInternalTagsの数に重み（例: 10）を乗算します。
// カレント記事自身と、既に手動で追加された記事は除外します。
let scoredByInternalTags: ScoredPost[] = [];
if (currentPost.InternalTags && currentPost.InternalTags.length > 0) {
  allPosts.forEach(post => {
    if (post.PageId === currentPost.PageId || relatedPostsToDisplay.some(rp => rp.PageId === post.PageId)) {
      return; // 自分自身と既に手動で選ばれた記事は除く
    }

    const commonInternalTagsCount = calculateCommonTags(currentPost.InternalTags, post.InternalTags);
    if (commonInternalTagsCount > 0) {
      scoredByInternalTags.push({ ...post, score: commonInternalTagsCount * 10 });
    }
  });
}

// --- 3. Tags に基づく関連記事のスコアリング ---
// allPosts から、Tags（表示用タグ）がカレント記事と共通する記事を候補として収集し、スコアリングします。
// スコアは共通するTagsの数です（重みは1）。
// カレント記事自身、手動で追加された記事、InternalTagsで既にスコアリングされた記事は除外します。
let scoredByDisplayTags: ScoredPost[] = [];
if (currentPost.Tags && currentPost.Tags.length > 0) {
  allPosts.forEach(post => {
    if (
      post.PageId === currentPost.PageId ||
      relatedPostsToDisplay.some(rp => rp.PageId === post.PageId) ||
      scoredByInternalTags.some(sit => sit.PageId === post.PageId)
    ) {
      return; // 自分自身、手動設定済み、InternalTagsでスコアリング済みの記事は除く
    }

    const commonDisplayTagsCount = calculateCommonTags(currentPost.Tags, post.Tags);
    if (commonDisplayTagsCount > 0) {
      scoredByDisplayTags.push({ ...post, score: commonDisplayTagsCount });
    }
  });
}

// --- 4. スコアリングされた記事候補をマージしてソート ---
// InternalTagsとTagsでスコアリングされた記事を一つのリストにまとめ、スコアの高い順にソートします。
let candidatePosts: ScoredPost[] = [...scoredByInternalTags, ...scoredByDisplayTags];
candidatePosts.sort((a, b) => b.score - a.score);

// --- 5. 最終的な関連記事リストを作成 ---
// 手動で設定された関連記事を優先し、残りの枠をスコア順に候補記事で埋めていきます。
// 最終的なリストの投稿数が maxPosts を超えないようにし、重複も排除します。
const finalPostIds = new Set(relatedPostsToDisplay.map(p => p.PageId));

for (const scoredPost of candidatePosts) {
  if (relatedPostsToDisplay.length >= maxPosts) {
    break;
  }
  if (!finalPostIds.has(scoredPost.PageId)) {
    relatedPostsToDisplay.push(scoredPost);
    finalPostIds.add(scoredPost.PageId);
  }
}

// 念のため、最終リストの件数がmaxPostsを超えていないか確認し、超えていれば調整
if (relatedPostsToDisplay.length > maxPosts) {
  relatedPostsToDisplay = relatedPostsToDisplay.slice(0, maxPosts);
}

---

{relatedPostsToDisplay && relatedPostsToDisplay.length > 0 && (
  <div class="related-posts">
    <h3 class="related-posts-title">関連記事</h3>
    <ul class="related-posts-list">
      {relatedPostsToDisplay.map((post: Post) => (
        <li class="related-post-item">
          <a href={getPostLink(post)} class="related-post-link">
            {post.FeaturedImage?.Url && (
              <div class="related-post-image-wrapper">
                <img 
                  src={filePath(new URL(post.FeaturedImage.Url))} 
                  alt={post.Title} 
                  class="related-post-image" 
                  loading="lazy"
                  width={post.FeaturedImage.Width || 150} 
                  height={post.FeaturedImage.Height || 100}
                />
              </div>
            )}
            <span class="related-post-title-text">{post.Title}</span>
          </a>
        </li>
      ))}
    </ul>
  </div>
)}

<style>
  .related-posts {
    margin-top: 3rem;
    padding-top: 1.5rem;
    border-top: 1px solid #eee;
  }
  .related-posts-title {
    font-size: 1.3rem;
    margin-bottom: 1rem;
    color: var(--fg);
  }
  .related-posts-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
  }
  .related-post-item {
  }
  .related-post-link {
    display: block;
    text-decoration: none;
    color: var(--fg);
    transition: opacity 0.2s ease;
  }
  .related-post-link:hover {
    opacity: 0.8;
  }
  .related-post-image-wrapper {
    margin-bottom: 0.5rem;
    aspect-ratio: 16 / 9;
    overflow: hidden;
    border-radius: var(--radius);
  }
  .related-post-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  .related-post-title-text {
    font-size: 0.95rem;
    font-weight: 500;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style> 