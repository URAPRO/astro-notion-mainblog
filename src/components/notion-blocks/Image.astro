---
import { ENABLE_LIGHTBOX } from '../../server-constants.ts'
import * as interfaces from '../../lib/interfaces'
import { filePath } from '../../lib/blog-helpers'
import Caption from './Caption.astro'

export interface Props {
  block: interfaces.Block
  slug?: string
  imageIndex?: number
}

const { block } = Astro.props

let imageSrc = ''
let webpSrc = '' // Large: 800px
let mediumSrc = '' // Medium: 400px
let smallSrc = '' // Small: 200px

if (block.Image?.External?.Url) {
  imageSrc = block.Image.External.Url
} else if (block.Image?.File?.Url) {
  const originalPath = filePath(new URL(block.Image.File.Url))
  imageSrc = originalPath

  // 各サイズのWebPパスを生成
  const pathParts = originalPath.split('.')
  const ext = pathParts.pop()
  const basePath = pathParts.join('.')

  // WebPファイルのパス
  webpSrc = `${basePath}.webp`
  mediumSrc = `${basePath}-md.webp`
  smallSrc = `${basePath}-sm.webp`
}

// srcset文字列を生成
const srcsetValue = [smallSrc, mediumSrc, webpSrc]
  .filter(Boolean)
  .map((url, i) => {
    const widths = [200, 400, 800]
    return `${url} ${widths[i]}w`
  })
  .join(', ')

// キャプションからの情報抽出
let specifiedWidthString = ''
let altText = 'Image from blog post'
let displayCaption = ''

if (block.Image?.Caption && block.Image.Caption.length > 0) {
  let captionInput = block.Image.Caption.map((c) => c.PlainText)
    .join('')
    .trim()
  const altRegex = /alt:((?:(?!size:).)+)/i
  const altMatch = captionInput.match(altRegex)
  if (altMatch && altMatch[1]) {
    altText = altMatch[1].trim()
    captionInput = captionInput.replace(altMatch[0], '').trim()
  }
  const sizeRegex = /(?:size:\s*|size\s*)(\d+)(px)?/i
  const sizeMatch = captionInput.match(sizeRegex)
  if (sizeMatch && sizeMatch[1]) {
    specifiedWidthString = sizeMatch[1].trim() + (sizeMatch[2] || 'px')
    captionInput = captionInput.replace(sizeMatch[0], '').trim()
  }
  displayCaption = captionInput
  if (altText === 'Image from blog post' && displayCaption) {
    altText = displayCaption
    displayCaption = ''
  }
  if (block.Image.Caption[0]?.Text) {
    if (displayCaption) {
      block.Image.Caption[0].Text.Content = displayCaption
    } else {
      block.Image.Caption = []
    }
  }
} else {
  // キャプションがない場合、ファイル名などからaltを生成
  if (block.Image?.File?.Url) {
    try {
      const urlParts = new URL(block.Image.File.Url).pathname.split('/')
      altText = decodeURIComponent(urlParts[urlParts.length - 1])
    } catch {}
  } else if (block.Image?.External?.Url) {
    try {
      const urlParts = new URL(block.Image.External.Url).pathname.split('/')
      altText = decodeURIComponent(urlParts[urlParts.length - 1])
    } catch {}
  }
}

// 名前付きサイズのマッピング
const namedSizes: Record<string, string> = {
  'xs': '150px',
  's': '300px',
  'm': '400px',
  'l': '500px',
  'xl': '700px',
}

// width と height の決定
let finalWidth: number | undefined
let finalHeight: number | undefined
let styleWidth: string | undefined

const originalWidth = block.Image?.Width
const originalHeight = block.Image?.Height

if (specifiedWidthString) {
  // 名前付きサイズをチェック
  const lowerSize = specifiedWidthString.toLowerCase().replace(/px$/, '')
  if (namedSizes[lowerSize]) {
    styleWidth = namedSizes[lowerSize]
    // 名前付きサイズの場合もHTML属性用に数値を計算
    const numericMatch = namedSizes[lowerSize].match(/^(\d+)px$/)
    if (numericMatch && originalWidth && originalHeight) {
      finalWidth = parseInt(numericMatch[1], 10)
      finalHeight = Math.round((originalHeight / originalWidth) * finalWidth)
    } else if (originalWidth && originalHeight) {
      finalWidth = originalWidth
      finalHeight = originalHeight
    }
  } else if (originalWidth && originalHeight) {
    // 数値指定の場合
    finalWidth = parseInt(specifiedWidthString, 10)
    if (!isNaN(finalWidth)) {
      finalHeight = Math.round((originalHeight / originalWidth) * finalWidth)
      styleWidth = `${finalWidth}px`
    } else {
      finalWidth = undefined
    }
  }
} else if (originalWidth && originalHeight) {
  finalWidth = originalWidth
  finalHeight = originalHeight
}
---

<figure class="image">
  {
    imageSrc && (
      <div style={styleWidth ? `max-width: ${styleWidth}` : undefined}>
        <div>
          {ENABLE_LIGHTBOX ? (
            <a data-fslightbox href={webpSrc || imageSrc} data-type="image">
              <picture>
                {srcsetValue && (
                  <source
                    srcset={srcsetValue}
                    sizes="(max-width: 400px) 400px, 800px"
                    type="image/webp"
                  />
                )}
                <img
                  src={webpSrc || imageSrc}
                  alt={altText}
                  width={finalWidth}
                  height={finalHeight}
                  loading="lazy"
                  decoding="async"
                />
              </picture>
            </a>
          ) : (
            <picture>
              {srcsetValue && (
                <source
                  srcset={srcsetValue}
                  sizes="(max-width: 400px) 400px, 800px"
                  type="image/webp"
                />
              )}
              <img
                src={webpSrc || imageSrc}
                alt={altText}
                width={finalWidth}
                height={finalHeight}
                loading="lazy"
                decoding="async"
              />
            </picture>
          )}
        </div>
        {block.Image?.Caption && block.Image.Caption.length > 0 && (
          <Caption richTexts={block.Image.Caption} />
        )}
      </div>
    )
  }
</figure>

<style>
  .image {
    display: flex;
    margin: 0.2rem auto 0;
  }
  .image > div {
    margin: 0 auto;
  }
  .image > div > div img {
    display: block;
    max-width: 100%;
    height: auto;
    /* 縮小表示時の品質向上 */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }
</style>
