---
import type * as interfaces from '../lib/interfaces.ts';
import type { RichText } from '../lib/interfaces.ts';
import { slugify } from '../lib/blog-helpers.ts';

export interface Props {
  headings: interfaces.Block[];
}

const { headings } = Astro.props;

// RichText[] からプレーンテキストを抽出
const extractPlainText = (richTexts: RichText[] | undefined): string => {
  if (!richTexts) return '';
  return richTexts.map(rt => rt.PlainText).join('');
};

// 見出し情報を整形
const tocItems = headings
  .map(heading => {
    let text = '';
    let level = 0;
    let richTexts: RichText[] | undefined;

    switch (heading.Type) {
      case 'heading_1':
        richTexts = heading.Heading1?.RichTexts;
        level = 1;
        break;
      case 'heading_2':
        richTexts = heading.Heading2?.RichTexts;
        level = 2;
        break;
      case 'heading_3':
        richTexts = heading.Heading3?.RichTexts;
        level = 3;
        break;
    }

    if (richTexts) {
      text = extractPlainText(richTexts);
    }

    if (text) {
      return { text, level, id: slugify(text) };
    }
    return null;
  })
  .filter((item): item is NonNullable<typeof item> => item !== null);
---

{tocItems.length > 0 && (
  <nav class="floating-toc" aria-labelledby="floating-toc-heading">
    <div class="floating-toc-inner">
      <h2 id="floating-toc-heading" class="floating-toc-title">目次</h2>
      <ul class="floating-toc-list">
        {tocItems.map(item => (
          <li class={`floating-toc-item floating-toc-item-level-${item.level}`}>
            <a href={`#${item.id}`} data-toc-link={item.id}>{item.text}</a>
          </li>
        ))}
      </ul>
    </div>
  </nav>
)}

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = document.querySelectorAll('[data-toc-link]');
    if (tocLinks.length === 0) return;

    // 見出し要素を取得（型ガードでnull安全に）
    const headingIds = Array.from(tocLinks)
      .map(link => link.getAttribute('data-toc-link'))
      .filter((id): id is string => !!id);
    const headings = headingIds
      .map(id => document.getElementById(id))
      .filter((el): el is HTMLElement => el !== null);

    if (headings.length === 0) return;

    let currentActiveId: string | null = null;

    const updateActiveLink = (activeId: string | null) => {
      if (currentActiveId === activeId) return;

      // 前のアクティブを解除
      tocLinks.forEach(link => link.classList.remove('active'));

      // 新しいアクティブを設定
      if (activeId) {
        const activeLink = document.querySelector(`[data-toc-link="${activeId}"]`);
        activeLink?.classList.add('active');
      }

      currentActiveId = activeId;
    };

    // スクロール位置に基づいてアクティブな見出しを更新
    const updateActiveLinkFromScroll = () => {
      const scrollTop = window.scrollY;
      let activeHeading: HTMLElement | null = null;

      for (const heading of headings) {
        if (heading.offsetTop - 100 <= scrollTop) {
          activeHeading = heading;
        } else {
          break;
        }
      }
      updateActiveLink(activeHeading?.id ?? null);
    };

    if ('IntersectionObserver' in window) {
      // Intersection Observer で現在の見出しを検出
      const observer = new IntersectionObserver(
        (entries) => {
          const visibleHeadings = entries
            .filter((entry) => entry.isIntersecting)
            .map((entry) => ({
              id: entry.target.id,
              top: entry.boundingClientRect.top,
            }));

          if (visibleHeadings.length > 0) {
            visibleHeadings.sort((a, b) => a.top - b.top);
            updateActiveLink(visibleHeadings[0].id);
          }
        },
        {
          rootMargin: '-80px 0px -60% 0px',
          threshold: 0,
        }
      );
      headings.forEach((heading) => observer.observe(heading));
    } else {
      // フォールバックとしてスクロールイベントリスナーを登録
      document.addEventListener('scroll', updateActiveLinkFromScroll, { passive: true });
    }

    // 初期表示時のアクティブ設定
    updateActiveLinkFromScroll();
  });
</script>

<style>
  .floating-toc {
    display: none;
    position: fixed;
    top: 120px;
    right: 20px;
    width: 220px;
    max-height: calc(100vh - 160px);
    overflow-y: auto;
    z-index: 100;
  }

  .floating-toc-inner {
    background: var(--bg, #faf8f5);
    border: 1px solid var(--border-color, #e8e2d9);
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
  }

  .floating-toc-title {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accents-2, #8b7355);
    margin: 0 0 0.75rem 0;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color, #e8e2d9);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .floating-toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .floating-toc-item {
    margin-bottom: 0.4rem;
    line-height: 1.4;
  }

  .floating-toc-item a {
    display: block;
    font-size: 0.8rem;
    color: var(--accents-2, #8b7355);
    text-decoration: none;
    padding: 0.2rem 0;
    transition: color 0.2s ease;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .floating-toc-item a:hover {
    color: var(--accents-1, #e07a3d);
  }

  .floating-toc-item a.active {
    color: var(--accents-1, #e07a3d);
    font-weight: 600;
  }

  .floating-toc-item-level-1 {
    font-weight: 500;
  }

  .floating-toc-item-level-2 {
    padding-left: 0.75rem;
  }

  .floating-toc-item-level-3 {
    padding-left: 1.5rem;
    font-size: 0.75rem;
  }

  .floating-toc-item-level-3 a {
    font-size: 0.75rem;
  }

  /* スクロールバーのスタイル */
  .floating-toc::-webkit-scrollbar {
    width: 4px;
  }

  .floating-toc::-webkit-scrollbar-track {
    background: transparent;
  }

  .floating-toc::-webkit-scrollbar-thumb {
    background: var(--border-color, #e8e2d9);
    border-radius: 2px;
  }

  /* PC (1200px以上) でのみ表示 */
  @media (min-width: 1200px) {
    .floating-toc {
      display: block;
    }
  }

  /* 大きめの画面では少し広く */
  @media (min-width: 1400px) {
    .floating-toc {
      width: 250px;
      right: 40px;
    }
  }
</style>
