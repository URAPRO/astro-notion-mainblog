---
import * as interfaces from '../../lib/interfaces.ts'
import {
  getPosts,
  getAllPosts,
  getRankedPosts,
  getPostBySlug,
  getPostsByTag,
  getBlock,
  getAllTags,
  getAllBlocksByBlockId,
  downloadFile,
} from '../../lib/notion/client.ts'
import {
  getPostLink,
  getPostFullLink,
  filePath,
  extractTargetBlocks,
} from '../../lib/blog-helpers.ts'
import { SocialShareButtons } from '../../components/ShareButton.tsx';
import Layout from '../../layouts/Layout.astro'
import PostDate from '../../components/PostDate.astro'
import PostUpdateDate from '../../components/PostUpdateDate.astro'
import PostTags from '../../components/PostTags.astro'
import PostTitle from '../../components/PostTitle.astro'
import PostBody from '../../components/PostBody.astro'
import PostRelativeLink from '../../components/PostRelativeLink.astro'
import BlogPostsLink from '../../components/BlogPostsLink.astro'
import BlogTagsLink from '../../components/BlogTagsLink.astro'
import styles from '../../styles/blog.module.css'

export async function getStaticPaths() {
  const posts = await getAllPosts()
  return posts.map((post: interfaces.Post) => ({ params: { slug: post.Slug } }))
}

const { slug } = Astro.params

const post = await getPostBySlug(slug)
if (!post) {
  throw new Error(`Post not found. slug: ${slug}`)
}

const [blocks, allPosts, rankedPosts, recentPosts, tags, postsHavingSameTag] =
  await Promise.all([
    getAllBlocksByBlockId(post.PageId),
    getAllPosts(),
    getRankedPosts(),
    getPosts(5),
    getAllTags(),
    getPostsByTag(post.Tags[0]?.name, 6),
  ])

const fileAtacchedBlocks = extractTargetBlocks('image', blocks)
  .concat(extractTargetBlocks('file', blocks))
  .filter((block) => {
    if (!block) {
      return false
    }
    const imageOrFile = block.Image || block.File;
    // Ensure File object and its Url exist
    return imageOrFile && imageOrFile.File && imageOrFile.File.Url;
  });

// Download files
const fileNameMappings = await Promise.all(
  fileAtacchedBlocks
    .map(async (block) => {
      const imageOrFile = block.Image || block.File
      if (!imageOrFile || !imageOrFile.File) return Promise.resolve({ blockId: block.Id, mapping: null })
      
      const expiryTime = imageOrFile.File.ExpiryTime
      if (expiryTime && Date.parse(expiryTime) > Date.now()) {
        return Promise.resolve({ blockId: block.Id, mapping: null })
      }
      return getBlock(block.Id).then(block => ({ blockId: block.Id, block }))
    })
    .map((promise) =>
      promise.then((data) => {
        if (!data || ('block' in data && !data.block)) return Promise.resolve({ blockId: data.blockId, mapping: null })
        
        if ('block' in data) {
          const block = data.block
          const imageOrFile = block.Image || block.File
          if (!imageOrFile || !imageOrFile.File) return Promise.resolve({ blockId: data.blockId, mapping: null })

          let url!: URL
          try {
            url = new URL(imageOrFile.File.Url)
          } catch {
            console.log('Invalid file URL: ', imageOrFile?.File?.Url)
            return Promise.resolve({ blockId: data.blockId, mapping: null })
          }
          return Promise.resolve({ blockId: data.blockId, url })
        }
        
        return Promise.resolve({ blockId: data.blockId, mapping: null })
      })
    )
    .map((promise, index) => 
      promise.then((data) => {
        if ('url' in data && data.url) {
          return downloadFile(data.url, post, index).then(mapping => ({ blockId: data.blockId, mapping }))
        }
        return Promise.resolve({ blockId: data.blockId, mapping: null })
      })
    )
)

// ブロックIDからファイル名マッピングへの辞書を作成
const blockIdToFileMappings: Record<string, any> = {}
fileNameMappings.forEach(item => {
  if (item && item.blockId && item.mapping) {
    blockIdToFileMappings[item.blockId] = item.mapping
  }
})

const currentPostIndex = allPosts.findIndex((post) => post.Slug === slug);
const prevPost = allPosts[currentPostIndex + 1];
const nextPost = allPosts[currentPostIndex - 1];

let ogImage = '';
if (post.FeaturedImage && post.FeaturedImage.Url) {
  const featuredImageURL = new URL(post.FeaturedImage.Url)
  ogImage = new URL(filePath(featuredImageURL), Astro.site).toString();
}
---

<Layout
  title={post.Title}
  path={getPostLink(post)}
  description={post.Excerpt}
  ogImage={ogImage}
>
  <div slot="main" class={`${styles.main} ${styles.postPage}`}>
    <div class={styles.post}>
      <PostTitle post={post} enableLink={false} />
      <div style="display: flex; flex-wrap: wrap; column-gap: 1em;">
        <PostDate post={post} />
        <PostUpdateDate post={post} />
      </div>
      <PostTags post={post} enableLink={true} />
      <PostBody blocks={blocks} post={post} blockIdToFileMappings={blockIdToFileMappings} />
      <SocialShareButtons title={post.Title} url={getPostFullLink(post)} tags={post.Tags} socialShareHashtags={post.SocialShareHashtags} client:load/>

      <footer>
        <PostRelativeLink prevPost={prevPost} nextPost={nextPost} />
      </footer>
    </div>
  </div>

  <div slot="aside" class="aside">
    <!--<BlogPostsLink-->
    <!--  heading="同じカテゴリーの記事"-->
    <!--  posts={postsHavingSameTag.filter(-->
    <!--    (p: interfaces.Post) => p.Slug !== post.Slug-->
    <!--  )}-->
    <!--/>-->
    <BlogPostsLink heading="最新記事" posts={recentPosts} />
    <BlogPostsLink heading="おすすめ記事" posts={rankedPosts} />
    <BlogTagsLink heading="カテゴリー" tags={tags} />
  </div>
</Layout>
